# -*- coding: utf-8 -*-
"""Exercicio01 - Grafos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15eU_PvpRGy9A3yL5H_QFI9L9ieTbGFrj

*Nome:* Wallan De Melo Lima
"""

import random
import mido
from mido import Message, MidiFile, MidiTrack
import numpy as np

# =================== Classes e métodos para representação de grafos ===================
# Esta classe representa um grafo direcionado e ponderado, utilizando
# tanto matriz de adjacência quanto lista de adjacência.
#
# Cada vértice pode possuir arestas direcionadas para outros vértices,
# associadas a pesos que representam custos, distâncias ou intervalos.
#
# A classe oferece métodos para criação do grafo a partir de vetores,
# cálculo de distâncias, conversão de representações e visualização.
class GrafoDirecionadoPonderado:
    """Classe para representar grafos direcionados e ponderados"""
    # Inicializa a estrutura básica do grafo.
    #
    # Caso uma lista de vértices seja fornecida, ela é armazenada; caso contrário,
    # o grafo inicia vazio. As representações por matriz e lista de adjacência
    # são inicializadas separadamente.
    def __init__(self, vertices=None):
        self.vertices = vertices if vertices else []
        self.adj_matrix = None
        self.adj_list = {}
    # Este método constrói um grafo completo ponderado a partir de um vetor
    # de notas musicais e seus respectivos intervalos.
    #
    # A direção do grafo pode ser ascendente ou descendente, influenciando
    # o cálculo dos pesos das arestas, que representam distâncias em semitons.
    #
    # Ao final do processo, a matriz de adjacência é convertida automaticamente
    # em uma lista de adjacência.
    #
    # Parâmetros:
    # - notas: lista de vértices do grafo.
    # - intervalos: vetor auxiliar de intervalos entre notas consecutivas.
    # - direcao: define se o grafo será ascendente ou descendente.

    def criar_do_vetor(self, notas, intervalos, direcao='asc'):
        """Cria grafo a partir de vetor de notas e intervalos"""
        self.vertices = notas

        n = len(notas)
        self.adj_matrix = [[0] * n for _ in range(n)]

        # Preenche a matriz de adjacências
        for i in range(n):
            for j in range(n):
                if i != j:
                    if direcao == 'asc':
                        # Distância ascendente
                        if j > i:
                            self.adj_matrix[i][j] = intervalos[j-1] if i == j-1 else self.calcular_distancia(notas[i], notas[j], 'asc')
                        else:
                            self.adj_matrix[i][j] = self.calcular_distancia(notas[i], notas[j], 'asc')
                    else:
                        # Distância descendente
                        self.adj_matrix[i][j] = self.calcular_distancia(notas[i], notas[j], 'desc')

        self.matriz_para_lista()
    # Este método calcula a distância musical entre duas notas da escala
    # cromática, considerando a direção do deslocamento.
    #
    # A distância é expressa em número de semitons e respeita a natureza
    # cíclica da escala cromática (oitava).
    #
    # Parâmetros:
    # - nota1: nota de origem.
    # - nota2: nota de destino.
    # - direcao: ascendente ou descendente.
    #
    # Retorno:
    # - Valor inteiro representando a distância em semitons.

    def calcular_distancia(self, nota1, nota2, direcao='asc'):
        """Calcula distância entre duas notas"""
        notas_cromaticas = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']

        idx1 = notas_cromaticas.index(nota1)
        idx2 = notas_cromaticas.index(nota2)

        if direcao == 'asc':
            # Distância ascendente (semitonos)
            if idx2 >= idx1:
                return idx2 - idx1
            else:
                return 12 - (idx1 - idx2)
        else:
            # Distância descendente (semitonos)
            if idx2 <= idx1:
                return idx1 - idx2
            else:
                return 12 - (idx2 - idx1)
    # Converte a matriz de adjacência do grafo em uma lista de adjacência.
    #
    # Cada vértice passa a ser associado a uma lista de pares (vizinho, peso),
    # facilitando operações de percurso e análise do grafo.

    def matriz_para_lista(self):
        """Converte matriz de adjacências para lista de adjacência (dicionário)"""
        self.adj_list = {}

        for i, vertice in enumerate(self.vertices):
            self.adj_list[vertice] = []
            for j, peso in enumerate(self.adj_matrix[i]):
                if peso != 0:
                    self.adj_list[vertice].append((self.vertices[j], peso))
    # Exibe no console as principais representações do grafo:
    # - lista de vértices,
    # - matriz de adjacência formatada,
    # - lista de adjacência.
    #
    # Esse método tem finalidade didática e de depuração.
    def mostrar_grafo(self):
        """Mostra representação do grafo"""
        print(f"\nVértices: {self.vertices}")
        print("\nMatriz de Adjacências:")
        for linha in self.adj_matrix:
            print([f"{x:3}" if x != 0 else "  0" for x in linha])

        print("\nLista de Adjacência:")
        for vertice, vizinhos in self.adj_list.items():
            print(f"{vertice}: {vizinhos}")

# =================== Solução dos exercícios ===================
# Esta classe implementa um sistema musical baseado em teoria dos grafos.
#
# O sistema utiliza grafos para representar relações entre notas musicais,
# permitindo a construção de escalas, percursos musicais e geração
# automática de melodias em formato MIDI.
class SistemaMusical:
    """Classe principal para o sistema musical"""

    def __init__(self):
        # Definindo notas da escala cromática
        self.notas_cromaticas = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
        # Intervalos entre notas consecutivas (todos semitonos)
        self.intervalos_cromaticos = [0.5] * 11

        # Definindo padrões de escalas (em semitonos)
        self.padroes_escalas = {
            'maior': [2, 2, 1, 2, 2, 2, 1],          # T, T, S, T, T, T, S
            'menor': [2, 1, 2, 2, 1, 2, 2],          # T, S, T, T, S, T, T
            'pentatonica': [3, 2, 2, 3, 2]           # Padrão pentatônica
        }

    # B.1) Representar grafos completos ponderados
    # Este método cria dois grafos completos ponderados baseados na escala
    # cromática: um ascendente e outro descendente.
    #
    # Cada grafo representa as distâncias entre notas considerando a direção
    # do movimento musical.
    #
    # Retorno:
    # - Grafo ascendente.
    # - Grafo descendente.
    def criar_grafos_cromaticos(self):
        """Cria grafos para intervalos ascendentes e descendentes"""

        # Grafo ascendente
        print("=" * 60)
        print("GRAFO ASCENDENTE COMPLETO PONDERADO")
        print("=" * 60)
        grafo_asc = GrafoDirecionadoPonderado()
        grafo_asc.criar_do_vetor(self.notas_cromaticas, self.intervalos_cromaticos, 'asc')
        grafo_asc.mostrar_grafo()

        # Grafo descendente
        print("\n" + "=" * 60)
        print("GRAFO DESCENDENTE COMPLETO PONDERADO")
        print("=" * 60)
        grafo_desc = GrafoDirecionadoPonderado()
        grafo_desc.criar_do_vetor(self.notas_cromaticas, self.intervalos_cromaticos, 'desc')
        grafo_desc.mostrar_grafo()

        return grafo_asc, grafo_desc

    # B.2) Algoritmo para encontrar escalas
    # Determina as notas que compõem uma escala musical a partir de um tom
    # inicial e de um padrão de intervalos.
    #
    # O cálculo respeita a estrutura da escala cromática e utiliza aritmética
    # modular para lidar com a repetição das oitavas.
    #
    # Parâmetros:
    # - tom: nota base da escala.
    # - tipo_escala: tipo da escala (maior, menor ou pentatônica).
    #
    # Retorno:
    # - Lista ordenada de notas que compõem a escala.
    def encontrar_escala(self, tom, tipo_escala='maior'):
        """
        Encontra as notas de uma escala a partir de um tom
        usando o grafo ascendente
        """
        if tom not in self.notas_cromaticas:
            raise ValueError(f"Tom inválido: {tom}")

        # Padrão da escala
        padrao = self.padroes_escalas[tipo_escala]

        # Encontrar índice do tom inicial
        idx_inicial = self.notas_cromaticas.index(tom)

        # Construir escala
        escala = [tom]
        idx_atual = idx_inicial

        for intervalo in padrao:
            # Avançar na escala cromática
            # Cada intervalo é em semitonos, converter para índices (1 semitono = 1 posição)
            idx_atual = (idx_atual + intervalo) % 12
            nota = self.notas_cromaticas[idx_atual]

            # Para evitar duplicatas (no caso da oitava)
            if nota not in escala:
                escala.append(nota)

        # Adicionar oitava se necessário
        if tipo_escala in ['maior', 'menor']:
            idx_final = (idx_inicial + 12) % 12
            if self.notas_cromaticas[idx_final] not in escala:
                escala.append(self.notas_cromaticas[idx_final])

        return escala
    # Simula o percurso de uma escala musical dentro de um grafo ascendente.
    #
    # O método identifica as transições entre notas consecutivas da escala
    # e calcula as distâncias em semitons, representando essas transições
    # como caminhos no grafo.
    #
    # Retorno:
    # - Lista de notas da escala percorrida.
    def percorrer_escala_no_grafo(self, tom, tipo_escala='maior'):
        """
        Percorre o grafo ascendente seguindo o padrão da escala
        """
        escala = self.encontrar_escala(tom, tipo_escala)

        print(f"\n{'='*60}")
        print(f"ESCALA {tipo_escala.upper()} EM {tom}")
        print(f"{'='*60}")
        print(f"Notas da escala: {escala}")

        # Simular percurso no grafo
        grafo_asc = GrafoDirecionadoPonderado()
        grafo_asc.criar_do_vetor(self.notas_cromaticas, self.intervalos_cromaticos, 'asc')

        print("\nPercursos possíveis no grafo ascendente:")
        for i in range(len(escala)-1):
            nota_atual = escala[i]
            nota_proxima = escala[i+1]

            # Encontrar peso da aresta
            idx_atual = self.notas_cromaticas.index(nota_atual)
            idx_proxima = self.notas_cromaticas.index(nota_proxima)

            # Calcular distância ascendente
            if idx_proxima >= idx_atual:
                distancia = idx_proxima - idx_atual
            else:
                distancia = 12 - (idx_atual - idx_proxima)

            print(f"  {nota_atual} → {nota_proxima}: {distancia} semitons")

        return escala

    # B.3) Gerar melodias com MIDI
    # Gera uma melodia aleatória utilizando apenas notas pertencentes
    # a uma escala previamente definida.
    #
    # As notas são escolhidas aleatoriamente, variando também a oitava,
    # e posteriormente convertidas para valores MIDI.
    #
    # Ao final, a melodia é exportada para um arquivo MIDI.
    #
    # Parâmetros:
    # - tom: tom base da melodia.
    # - tipo_escala: tipo de escala utilizada.
    # - num_notas: quantidade de notas da melodia.
    # - duracao_nota: duração de cada nota em segundos.
    #
    # Retorno:
    # - Lista da melodia em notas musicais.
    # - Lista correspondente de valores MIDI.
    def gerar_melodia(self, tom, tipo_escala='maior', num_notas=16, duracao_nota=0.5):
        """
        Gera uma melodia aleatória dentro de uma escala
        e cria um arquivo MIDI
        """
        # Obter escala
        escala = self.encontrar_escala(tom, tipo_escala)

        print(f"\n{'='*60}")
        print(f"GERANDO MELODIA EM {tom} {tipo_escala.upper()}")
        print(f"{'='*60}")
        print(f"Escala: {escala}")

        # Mapeamento de notas para números MIDI (C4 = 60)
        nota_base_midi = 60  # C4

        # Encontrar o índice MIDI do tom base
        idx_tom = self.notas_cromaticas.index(tom)
        offset_midi = nota_base_midi - idx_tom

        # Gerar melodia aleatória
        melodia = []
        notas_midi = []

        print("\nMelodia gerada:")
        for i in range(num_notas):
            # Escolher nota aleatória da escala
            nota = random.choice(escala)

            # Escolher oitava aleatória (3, 4 ou 5)
            oitava = random.choice([3, 4, 5])

            # Calcular número MIDI
            idx_nota = self.notas_cromaticas.index(nota)
            nota_midi = idx_nota + (oitava * 12)

            # Adicionar à melodia
            melodia.append((nota, oitava))
            notas_midi.append(nota_midi)

            print(f"  Nota {i+1}: {nota}{oitava} (MIDI: {nota_midi})")

        # Criar arquivo MIDI
        self.criar_arquivo_midi(notas_midi, duracao_nota, tom, tipo_escala)

        return melodia, notas_midi

    # Cria um arquivo MIDI a partir de uma sequência de notas MIDI.
    #
    # Cada nota é adicionada à trilha com mensagens de ativação (note_on)
    # e desativação (note_off), respeitando a duração especificada.
    #
    # O arquivo gerado pode ser reproduzido em qualquer software compatível
    # com o padrão MIDI.
    def criar_arquivo_midi(self, notas_midi, duracao_nota, tom, tipo_escala):
        """
        Cria um arquivo MIDI a partir das notas geradas
        """
        # Criar novo arquivo MIDI
        mid = MidiFile()
        track = MidiTrack()
        mid.tracks.append(track)

        # Configurar instrumento (piano = 0)
        track.append(Message('program_change', program=0, time=0))

        # Adicionar notas
        tempo_por_nota = int(duracao_nota * 480)  # ticks por nota (480 ticks = 1 segundo)

        for nota_midi in notas_midi:
            # Nota ON
            track.append(Message('note_on', note=nota_midi, velocity=64, time=0))
            # Nota OFF após duração
            track.append(Message('note_off', note=nota_midi, velocity=64, time=tempo_por_nota))

        # Salvar arquivo
        nome_arquivo = f"melodia_{tom}_{tipo_escala}.mid"
        mid.save(nome_arquivo)

        print(f"\nArquivo MIDI salvo como: {nome_arquivo}")


    def interface_usuario(self):
        """Interface interativa com o usuário"""
        print("=" * 60)
        print("SISTEMA MUSICAL COM TEORIA DOS GRAFOS")
        print("=" * 60)

        while True:
            print("\nOpções:")
            print("1. Visualizar grafos cromáticos")
            print("2. Encontrar escalas")
            print("3. Gerar melodia aleatória")
            print("4. Sair")

            opcao = input("\nEscolha uma opção (1-4): ")

            if opcao == '1':
                # B.1
                self.criar_grafos_cromaticos()

            elif opcao == '2':
                # B.2
                tom = input("Digite o tom (ex: C, D#, A): ").strip().upper()
                tipo = input("Digite o tipo de escala (maior/menor/pentatonica): ").strip().lower()

                if tom in self.notas_cromaticas and tipo in self.padroes_escalas:
                    self.percorrer_escala_no_grafo(tom, tipo)
                else:
                    print("Entrada inválida!")

            elif opcao == '3':
                # B.3
                tom = input("Digite o tom (ex: C, D#, A): ").strip().upper()
                tipo = input("Digite o tipo de escala (maior/menor/pentatonica): ").strip().lower()

                if tom in self.notas_cromaticas and tipo in self.padroes_escalas:
                    try:
                        num_notas = int(input("Número de notas na melodia (padrão: 16): ") or "16")
                        duracao = float(input("Duração de cada nota em segundos (padrão: 0.5): ") or "0.5")

                        self.gerar_melodia(tom, tipo, num_notas, duracao)
                    except ValueError:
                        print("Valor inválido!")
                else:
                    print("Entrada inválida!")

            elif opcao == '4':
                print("Saindo...")
                break
            else:
                print("Opção inválida!")

# =================== executar ===================
if __name__ == "__main__":
    try:
        # Verificar se o mido está instalado
        import mido
    except ImportError:
        print("AVISO: A biblioteca 'mido' não está instalada.")
        print("Para instalar: pip install mido")
        print("Para a geração de MIDI, será necessário instalar essa biblioteca.")
        print("Continuando sem suporte a MIDI...")

    # Criar sistema musical
    sistema = SistemaMusical()

    # Executar interface
    sistema.interface_usuario()