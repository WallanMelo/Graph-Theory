# -*- coding: utf-8 -*-
"""Trabalho Avaliativo - Grafos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16axjSB-ptTai-vKSIEK7MAAIdBvYCQR-

#Alunos: Clebson Santos, Victor Guedes e Wallan Melo

#Respostas das questões

##Questão A

A) A representação de grafos mais eficiente nesse cenário é a matriz de adjacência. Isso porquê o número de vértices no grafo é baixo (N = 28), além de serem estáticos (cada estado envia a encomenda para 1 aeroporto de outro estado, pelo mostrado na planilha). Onde cada vértice representa uma cidade, e cada aresta representa o tempo de viagem da conexão, se tornando um grafo ponderado.
Segue abaixo o código da representação do grafo em matriz de adjacência.
"""

### Imports necessários
import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import copy

##################Imports dos dados (baixar no collab) ###########################
fluxo = pd.read_excel("/content/LIG_AEREAS_2019-2020_fluxos_od.xlsx", usecols=["NOME_CID_O", "NOME_CID_D", "VAR05"])
aeroportos = pd.read_excel("/content/Aeroportos e Distâncias.xlsx", usecols=["Cidade", "Estado"])

grafo = np.zeros((len(aeroportos.index), len(aeroportos.index)))

########## Interpolação dos dados, para chegar no tempo percorrido
for i in aeroportos.itertuples():
  for j in aeroportos.itertuples():
    if str(i.Cidade) != str(j.Cidade):
      for k in fluxo.itertuples(index=False):

        if str(i.Cidade) in str(k.NOME_CID_O) and str(j.Cidade) in str(k.NOME_CID_D):
          if (k.VAR05 is None) or (k.VAR05 == 'Não há voo direto'):
            grafo[i.Index][j.Index] = 0
            break
          else:
            grafo[i.Index][j.Index] = k.VAR05
            break


print(pd.DataFrame(grafo)) ## pode-se usar apenas print(grafo), se quiser ver o grafo todo

"""##Sequência de letras B
###B) Serão 14 aeroportos que precisam ser alocados para os aviões pernoitarem, sendo os índices de cidade: "2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 15, 18, 22, 25"

###B.1) Foi notado que esse problema pode ser resolvido atráves da coloração dos vértices, entretando, foi analisado a posibilidade de combinar as técnicas de cobertura dos vértices + emparelhamento máximo, isso porquê o tamanho emparelhamento máximo seria exatamente igual ao tamanho mínimo da cobertura de vértices, que é o resultado do problema (O menor número possível de aeroportos que cobre o maior número possível de conexões). Entretanto, problema dessa combinação é que só funcionaria em grafos bipartidos que não tenham ciclos ímpares. Em uma análise visual do grafo, temos que as arestas 0-6, 6-2, 2-0 formam um clico ímpar, provando que o grafo não é bipartido.

###A partir disso, vai ser usado apenas a técnica de cobertura de vértices, até encontrar o menor número de vértices que englobam todas as arestas, e seu conjunto.

###B.2) Como é pedido o menor número possível de aeroportos, ao invés de fazer um algoritmo de cobertura de vértices clássico, ou seja "Na força bruta", foi pesquisado formas melhores formas de fazer esse algoritmo. A encontrada foi a "BackTracking" Que é um algoritmo de busca semelhante ao algoritmo de busca em profundidade, com a diferença que ele consegue retroceder se atingir um determinado ponto, voltando ao vértice anterior para tentar outra alternativa. Vai ser usado em conjunto com o Branch and Bound, que funciona criando ramificações do espaço de soluções e utiliza limites superiores ou inferiores para descartar subárvores que não podem conter a solução ótima.

"""

def coberturaVertices(grafo):
  G = np.array(grafo)
  melhor = {"tamanho": 99999999, "conjunto": set()}

  def extrairArestas(M): ##Extrai arestas a partir de uma matriz (Quando não conseguir extrair mais nada, encontramos um conjunto de cobertura válido)
    arestas = []
    for i in range(G.shape[0]):
      for j in range((i+1), G.shape[1]):
        if M[i][j] != 0:
          arestas.append((i, j))
    return arestas

  def removerArestas(M, v): ## Remove as arestas que incidem no vértice v
    for i in range(G.shape[1]): ## Para cada vértice
      M[v][i] = 0 ##Remove a conexão da linha v com coluna i
      M[i][v] = 0 ##Remove a conexão da linha i com coluna v

  def backTrack(M, cAtual): ## Função onde ocorre o backtrack
    arestas = extrairArestas(M) ##Extrai as arestas no estado atual do grafo

    if not arestas: ##Se não existir mais arestas, encontramos um conjunto válido
      if len(cAtual) < melhor["tamanho"]: ##Se o tamanho do conjunto encontrado for menor que o melhor já encontrado
        melhor["tamanho"] = len(cAtual) ##Pegamos esse conjunto
        melhor["conjunto"] = cAtual ##e o armazenamos
      return

    if len(cAtual) >= melhor["tamanho"]: ## Uma parte da tecnica Branch and Bound, cortamos a ramificação se ela já se apresentar maior que o melhor caso encontrado (Bound)
      return

    i, j = arestas[0] ## Escolhe uma aresta que não esteja coberta

    M1 = copy.deepcopy(M) ## É a parte tecnica Branch and Bound, copy.deepcopy(M) copia a matriz M de forma totalmente nova e independente, na sua forma atual da função (Branch)
    removerArestas(M1, i) ## Remove todas as arestas incidentes em i da matriz
    backTrack(M1, cAtual | {i}) ## Refaz o processo (o secundo parâmetro une o conjunto atual com i, ou seja, i passa à pertencer ao conjunto atual (cAtual))

    M2 = copy.deepcopy(M) ## A mesma coisa que a parte anterior, sendo a segunda ramificação
    removerArestas(M2, j) ## Remove todas as arestas incidentes em j da matriz
    backTrack(M2, cAtual | {j})## Refaz o processo (mesmo funcionamento que na ramificação anterior)

  backTrack(G, set()) ##inicia tudo
  return melhor["tamanho"], melhor["conjunto"]

quantidadeAeroportos, aeroportoPernoitado = coberturaVertices(grafo)
print(f'Serão {quantidadeAeroportos} aeroportos necessários para garantir que todos os aviões consigam passar a noite, sendo nos índices de cidade {aeroportoPernoitado}')

"""# Letra C"""


fluxo = pd.read_excel(
    "/content/LIG_AEREAS_2019-2020_fluxos_od.xlsx",
    usecols=["NOME_CID_O", "NOME_CID_D", "VAR05"]
)

aeroportos = pd.read_excel(
    "/content/Aeroportos e Distâncias.xlsx",
    usecols=["Cidade", "Estado"]
)

capitais = {
    "Rio Branco", "Maceió", "Manaus", "Macapá", "Salvador",
    "Fortaleza", "Brasília", "Vitória", "Goiânia", "São Luís",
    "Belo Horizonte", "Campo Grande", "Cuiabá", "Belém",
    "João Pessoa", "Recife", "Teresina", "Curitiba",
    "Rio de Janeiro", "Natal", "Porto Velho", "Boa Vista",
    "Porto Alegre", "Florianópolis", "Aracaju", "São Paulo",
    "Palmas"
}

aeroportos = aeroportos[aeroportos["Cidade"].isin(capitais)].reset_index(drop=True)

n = len(aeroportos)
grafo = np.full((n, n), np.inf)  # infinito = sem voo direto
np.fill_diagonal(grafo, 0)

#A coluna VAR05 representa o tempo médio de voo direto entre as capitais.
#ela é convertida para o tipo numérico para permitir comparações e cálculos.
#O parâmetro errors="coerce" garante que valores inválidos ou não numéricos
#sejam convertidos em NaN, evitando erros durante o processamento.
fluxo["VAR05"] = pd.to_numeric(fluxo["VAR05"], errors="coerce")

#A matriz 'grafo' representa a matriz de adjacência do grafo:
#cada linha e cada coluna correspondem a uma capital,
#e cada posição (i, j) armazena o tempo de voo direto entre
#a capital i (origem) e a capital j (destino), quando existente.
for i in aeroportos.itertuples():
    for j in aeroportos.itertuples():

        #Evita a criação de laços (voos de uma capital para ela mesma),
        #pois eles não fazem sentido no contexto do problema.
        if i.Cidade == j.Cidade:
            continue

        #Busca no conjunto de dados de fluxos a existência de um voo direto
        #cuja cidade de origem seja i.Cidade e a cidade de destino seja j.Cidade.
        registro = fluxo[
            (fluxo["NOME_CID_O"] == i.Cidade) &
            (fluxo["NOME_CID_D"] == j.Cidade)
        ]

        #Caso exista ao menos um registro de voo direto entre as capitais,
        #o tempo médio de voo é extraído para análise.
        if not registro.empty:
            tempo = registro.iloc[0]["VAR05"]

            #Apenas conexões cujo tempo médio de voo seja válido (não nulo)
            #e menor ou igual a 120 minutos são consideradas,
            #respeitando a restrição de autonomia máxima das aeronaves.
            #Quando a condição é satisfeita, o valor do tempo é armazenado
            #na matriz de adjacência, indicando a existência de uma aresta
            #entre as duas capitais.
            if pd.notna(tempo) and tempo <= 120:
                grafo[i.Index, j.Index] = tempo

df_grafo = pd.DataFrame(
    grafo,
    index=aeroportos["Cidade"],
    columns=aeroportos["Cidade"]
)

df_grafo

G = nx.Graph()

for i in range(n):
    for j in range(n):
        if grafo[i, j] != np.inf and grafo[i, j] != 0:
            G.add_edge(
                aeroportos.loc[i, "Cidade"],
                aeroportos.loc[j, "Cidade"],
                weight=grafo[i, j]
            )

print("Capitais:", G.number_of_nodes())
print("Conexões válidas:", G.number_of_edges())

def gerar_rotas_minimas(G):
    visitados = set()
    rotas = []

    for no in G.nodes():
        if no in visitados:
            continue

        rota = [no]
        visitados.add(no)
        atual = no

        while True:
            vizinhos = [
                v for v in G.neighbors(atual)
                if v not in visitados
            ]

            if not vizinhos:
                break

            proximo = min(
                vizinhos,
                key=lambda v: G[atual][v]["weight"]
            )

            rota.append(proximo)
            visitados.add(proximo)
            atual = proximo

        rotas.append(rota)

    return rotas

"""###Os resultados indicam que, sob o critério de tempo máximo de 120 minutos, o sistema de conexões aéreas entre as capitais analisadas forma uma estrutura linear e totalmente conectada.
###A existência de apenas uma rota mínima necessária mostra que uma organização simples da malha aérea, na qual uma capital intermediária (Manaus) atua como ponto central de conexão.
"""

rotas = gerar_rotas_minimas(G)

print(f"Número mínimo aproximado de rotas necessárias: {len(rotas)}\n")
for i, r in enumerate(rotas, 1):
    print(f"Rota {i}: {' -> '.join(r)}")

import matplotlib.pyplot as plt

pos = nx.spring_layout(G, seed=42)

nx.draw(
    G, pos,
    with_labels=True,
    node_size=2000,
    font_size=10
)

labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

plt.show()

"""**D)** Como as equipes de terra serão pequenas, deve-se evitar ter duas aeronaves chegando ou saindo no mesmo aeroporto na mesma janela de tempo.

**D.1)** Como montar a tabela de horários de vôos para atender à essa requisição?  Descreva a estratégia de algoritmos empregada;

**D.2)** Quais técnicas da Teoria dos Grafos podem ser empregadas na análise da solução desse problema?
"""

# ==================== CARREGAR DADOS ====================
fluxo = pd.read_excel(
    "LIG_AEREAS_2019-2020_fluxos_od.xlsx",
    usecols=["NOME_CID_O", "NOME_CID_D", "VAR05"]
)

aeroportos = pd.read_excel(
    "Aeroportos e Distâncias.xlsx",
    usecols=["Cidade", "Estado"]
)

# Filtrar apenas capitais
capitais = {
    "Rio Branco", "Maceió", "Manaus", "Macapá", "Salvador",
    "Fortaleza", "Brasília", "Vitória", "Goiânia", "São Luís",
    "Belo Horizonte", "Campo Grande", "Cuiabá", "Belém",
    "João Pessoa", "Recife", "Teresina", "Curitiba",
    "Rio de Janeiro", "Natal", "Porto Velho", "Boa Vista",
    "Porto Alegre", "Florianópolis", "Aracaju", "São Paulo",
    "Palmas"
}

aeroportos = aeroportos[aeroportos["Cidade"].isin(capitais)].reset_index(drop=True)
n = len(aeroportos)

# cração da matriz de adjacência com grafo direcionado
grafo = np.full((n, n), np.inf) #infinito sem voo direto
np.fill_diagonal(grafo, 0)

fluxo["VAR05"] = pd.to_numeric(fluxo["VAR05"], errors="coerce")

for i in aeroportos.itertuples():
    for j in aeroportos.itertuples():
        if i.Cidade == j.Cidade:
            continue

        registro = fluxo[
            (fluxo["NOME_CID_O"] == i.Cidade) &
            (fluxo["NOME_CID_D"] == j.Cidade)
        ]

        if not registro.empty:
            tempo = registro.iloc[0]["VAR05"]
            if pd.notna(tempo) and tempo <= 120:
                grafo[i.Index, j.Index] = tempo

# criação de dict no mapeamento cidade ----> íindice
cidadeParaIndice = {row.Cidade: idx for idx, row in aeroportos.iterrows()}
indiceParaCidade = {idx: row.Cidade for idx, row in aeroportos.iterrows()}

# ==================== gerando lsit de oos p escalornar ====================
voos = []

# p/ cada conexao direta no grafo, é criado um nv voo
for i in range(n):
    for j in range(n):
        if grafo[i, j] != np.inf and grafo[i, j] != 0:
            voos.append({
                'origem': indiceParaCidade[i],
                'destino': indiceParaCidade[j],
                'duracao_min': grafo[i, j],
                'origem_idx': i,
                'destino_idx': j
            })

print(f"Total de voos a escalonar: {len(voos)}")

# ==================== Algoritmo de Escalonamento ====================
def escalonar_voos(voos, tempo_servico=30, inicio_dia=6):

#    Escalona voos para evitar conflitos em aeroportos
#    Parâmetros utilizados:
#    - voos: lista de dicionários com informações dos voos
#    - tempo_servico: tempo necessário para preparação no solo (minutos)
#    - inicio_dia: hora de início das operações (0-23)
#    Retorna:
#    - DataFrame com horários escalonados
#    - dicionário com ocupação por aeroporto

    # inicia os hosrarios disp por aeroporto
    horarios_livres = {}
    for cidade in aeroportos["Cidade"].unique():
        horarios_livres[cidade] = [(inicio_dia * 60, inicio_dia * 60 + 24*60)]  # [inicio, fim) em mins

    # ordenar os voos por duracao, om os voos mais curtos primeiros
    voos_ordenados = sorted(voos, key=lambda x: x['duracao_min'])

    horarios_escalonados = []

    for voo in voos_ordenados:
        origem = voo['origem']
        destino = voo['destino']
        duracao = voo['duracao_min']

        # variavel p/ encontrar o horario da partida
        horario_partida = None

        for inicio, fim in horarios_livres[origem]:
            # verifica se há tempo p/ partida + tempo de servico
            if fim - inicio >= tempo_servico:
                horario_partida = inicio
                break

        if horario_partida is None:
            # caso ñ seja encontrado  horario neste dia, ent adiciona no próximo dia
            ultimo_horario = max([fim for inicio, fim in horarios_livres[origem]])
            horario_partida = ultimo_horario

        # verifica se o horário de partida também está livre no destino, mas considerando o horário de chegada
        horario_chegada = horario_partida + duracao

        # Verificar janela no destino (chegada + tempo de serviço)
        destino_disponivel = False

        for inicio, fim in horarios_livres[destino]:
            # Verificar se a chegada + tempo de serviço cabe na janela
            if (inicio <= horario_chegada and
                fim - max(inicio, horario_chegada) >= tempo_servico):
                destino_disponivel = True
                break

        if not destino_disponivel:
            # Ajustar horário de partida para quando o destino estiver disponível
            for inicio, fim in horarios_livres[destino]:
                if fim - inicio >= tempo_servico:
                    # Calcular novo horário de partida baseado na disponibilidade do destino
                    novo_horario_partida = max(horario_partida, inicio - duracao)
                    if novo_horario_partida <= fim - duracao - tempo_servico:
                        horario_partida = novo_horario_partida
                        horario_chegada = horario_partida + duracao
                        break

        # Registrar o voo escalonado
        horarios_escalonados.append({
            'Origem': origem,
            'Destino': destino,
            'Duração (min)': duracao,
            'Partida (min)': horario_partida,
            'Chegada (min)': horario_chegada
        })

        # Atualizar horários livres nos aeroportos
        # Na origem: ocupar [partida, partida + tempo_servico)
        horarios_livres[origem] = atualizar_janelas(
            horarios_livres[origem], horario_partida, tempo_servico)

        # No destino: ocupar [chegada, chegada + tempo_servico)
        horarios_livres[destino] = atualizar_janelas(
            horarios_livres[destino], horario_chegada, tempo_servico)

    return pd.DataFrame(horarios_escalonados), horarios_livres

def atualizar_janelas(janelas, inicio_ocupacao, duracao_ocupacao):
    """
    Atualiza as janelas de tempo livres removendo um intervalo ocupado

    Parâmetros:
    - janelas: lista de tuplas (início, fim) representando intervalos livres
    - inicio_ocupacao: início do intervalo a ser ocupado
    - duracao_ocupacao: duração da ocupação

    Retorna:
    - Nova lista de janelas livres
    """
    fim_ocupacao = inicio_ocupacao + duracao_ocupacao
    novas_janelas = []

    for inicio, fim in janelas:
        if fim <= inicio_ocupacao or inicio >= fim_ocupacao:
            # Intervalo completamente livre
            novas_janelas.append((inicio, fim))
        elif inicio < inicio_ocupacao and fim > fim_ocupacao:
            # Ocupação no meio do intervalo - dividir em dois
            novas_janelas.append((inicio, inicio_ocupacao))
            novas_janelas.append((fim_ocupacao, fim))
        elif inicio < inicio_ocupacao and fim > inicio_ocupacao:
            # Ocupação começa dentro do intervalo
            novas_janelas.append((inicio, inicio_ocupacao))
        elif inicio < fim_ocupacao and fim > fim_ocupacao:
            # Ocupação termina dentro do intervalo
            novas_janelas.append((fim_ocupacao, fim))
        # Casos onde o intervalo está completamente ocupado são ignorados

    return novas_janelas

def converter_minutos_para_horario(minutos):
    #Converte minutos desde meia-noite para formato HH:MM
    # Converter para inteiro se for float
    if isinstance(minutos, float):
        minutos = int(minutos)
    horas = minutos // 60
    minutos_rest = minutos % 60
    return f"{horas:02d}:{minutos_rest:02d}"

# ==================== Execuatando o Escalonamento ====================
print("\nExecutando escalonamento de voos...")
df_escalonado, ocupacao = escalonar_voos(voos, tempo_servico=30, inicio_dia=6)

# faz a conversão de mins p/ horarios legiveis
df_escalonado['Partida'] = df_escalonado['Partida (min)'].apply(converter_minutos_para_horario)
df_escalonado['Chegada'] = df_escalonado['Chegada (min)'].apply(converter_minutos_para_horario)

# faz aordenação p horario de partida
df_escalonado = df_escalonado.sort_values('Partida (min)').reset_index(drop=True)

# ==================== Analise e Validação ====================
print("\n" + "="*75)
print("TABELA DE HORÁRIOS ESCALONADOS")

# mostra as primieras 10 linhas da tabela
print(df_escalonado[['Origem', 'Destino', 'Partida', 'Chegada', 'Duração (min)']].head(20))

print(f"\nTotal de voos escalonados: {len(df_escalonado)}")

# Faz uma análise de conflitos
print("ANÁLISE DE CONFLITOS POR AEROPORTO")

for cidade in aeroportos["Cidade"].unique():
    voos_cidade = df_escalonado[
        (df_escalonado['Origem'] == cidade) |
        (df_escalonado['Destino'] == cidade)
    ].copy()

    if len(voos_cidade) > 0:
        print(f"\nAeroporto: {cidade}")
        print(f"Total de operações (chegadas + partidas): {len(voos_cidade)}")

        # verifica os conflitos
        operacoes = []

        # adicionaa as partidas
        for _, row in voos_cidade[voos_cidade['Origem'] == cidade].iterrows():
            operacoes.append({
                'tipo': 'PARTIDA',
                'horario': row['Partida (min)'],
                'fim': row['Partida (min)'] + 30,
                'voo': f"{row['Origem']}->{row['Destino']}"
            })

        # adicionaa chegadas
        for _, row in voos_cidade[voos_cidade['Destino'] == cidade].iterrows():
            operacoes.append({
                'tipo': 'CHEGADA',
                'horario': row['Chegada (min)'],
                'fim': row['Chegada (min)'] + 30,
                'voo': f"{row['Origem']}->{row['Destino']}"
            })

        # ordena as operações por horário
        operacoes.sort(key=lambda x: x['horario'])

        # Verifica as sobreposições
        conflitos = []
        for i in range(len(operacoes) - 1):
            if operacoes[i]['fim'] > operacoes[i + 1]['horario']:
                conflitos.append((
                    operacoes[i]['voo'], operacoes[i]['tipo'],
                    operacoes[i + 1]['voo'], operacoes[i + 1]['tipo']
                ))

        if conflitos:
            print(f"  CONFLITOS DETECTADOS: {len(conflitos)}")
            for conflito in conflitos[:3]:  # Mostrar apenas os 3 primeiros
                print(f"    {conflito[0]} ({conflito[1]}) conflita com {conflito[2]} ({conflito[3]})")
        else:
            print(f"  ✓ Sem conflitos detectados")

# ==================== MOstrabdo o Resultado do escalonamento ====================

try:
    print("\n" + "="*75)
    print("GERANDO VISUALIZAÇÃO DO ESCALONAMENTO...")

    # cria a figura
    fig, ax = plt.subplots(figsize=(15, 10))

    aeroportos_lista = sorted(aeroportos["Cidade"].unique())
    y_positions = {aeroporto: i for i, aeroporto in enumerate(aeroportos_lista)}

    colors = plt.cm.tab20(np.linspace(0, 1, len(aeroportos_lista)))

    # plo das partidas
    for idx, row in df_escalonado.iterrows():
        ax.barh(y_positions[row['Origem']],
                width=0.5,  # defini a largura fixa para partidas
                left=row['Partida (min)'] / 60,  # converte p/ horas
                height=0.4,
                color=colors[y_positions[row['Origem']]],
                alpha=0.7,
                edgecolor='black')

        # chegada
        ax.barh(y_positions[row['Destino']],
                width=0.5,  # defini a largura fixa para chegadas
                left=row['Chegada (min)'] / 60,  # converter p/ horas
                height=0.4,
                color=colors[y_positions[row['Destino']]],
                alpha=0.7,
                edgecolor='black')

        ax.plot([row['Partida (min)'] / 60, row['Chegada (min)'] / 60],
                [y_positions[row['Origem']], y_positions[row['Destino']]],
                'gray', alpha=0.3, linewidth=0.5)

    ax.set_yticks(list(y_positions.values()))
    ax.set_yticklabels(list(y_positions.keys()))
    ax.invert_yaxis()  # inverter para ter o topo como primeiro

    ax.set_xlabel('Hora do Dia')
    ax.set_title('Escalonamento de Voos - Diagrama de Gantt')

    hours = np.arange(6, 24, 2)
    ax.set_xticks(hours)
    ax.set_xticklabels([f'{h:02d}:00' for h in hours])

    plt.tight_layout()
    plt.savefig('escalonamento_voos.png', dpi=150, bbox_inches='tight')
    print("Visualização salva como 'escalonamento_voos.png'")

except ImportError:
    print("\nMatplotlib não disponível para visualização")