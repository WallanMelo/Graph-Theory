# -*- coding: utf-8 -*-
"""Prova - Grafos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/132nDnp71x8saj88Q90G7jZweOiq_o6Hu

**Prova ☠️☠️ - Teoria dos Grafos**

**Aluno:** Wallan de Melo Liam

**Matrícula:** 160915, **Nascimento** 25/03/2003

**Professor:** Petras

**Data de Entrega:** 05/02/2025
"""

import itertools
import math
import random

"""Então como eu sou mt azarado ou sortudo não sei o que achar disso, mas basicamente os dois parametros meus irão dar 0 kkkkk, mas pensando na resolução das questão tomei a liberdade de para não utilizar 0 e definir o valor dos parametros de forma aleatoria o que pensei ofi o seguinte:

Irei pegar  um valor aleatorio de 1 até o resultado da divisão de por exemplo dia do meu niver no caso 25 por 5, dessa as formulas usadas serias as seguintes:  

                            PARAMETROS
  A = random.randint(1, (15 dividido por 3))
  
  B = random.randint(1, (25 dividido por 5))

"""

# ======================= Definição dos Valores Dos Parametros =======================
print("=" * 75)
print("Parte do Calculo dos Parametro A e B")
print("Matrícula: 160915, o enunciado pede para usar no calculo somente os dois ultimos  digots sendo assim o numero de 15")
print("Dia de Nasc: 25")
print("=" * 75)


# Definição de variaveis c os dados p usar no calculo dos parametros
matricula = 160915
dois_ultimos_digitos = 15
dia_nascimento = 25

# CALCULO conforme o PEDIDO no ENUNCIADO acima
print("Results:")
print(f"A = (dois últimos dígitos) % 3 = {dois_ultimos_digitos} % 3 = {dois_ultimos_digitos % 3}")
print(f"B = (dia do nascimento) % 5 = {dia_nascimento} % 5 = {dia_nascimento % 5}")

print("TEMOS UM PROBLEMA q Já Foi mencionado no bloco de texto anterior: Os resultados do resto da divião são 0")

# Usar semente baseada na matrícula para garantir reprodutibilidade
random.seed(matricula)

# Caclulo seguindo a minha logica de definição dos parametros, como resolução p/ o problema do resto = 0
print("RESULTADO DA IDEIA PROPOSTA")
print("Quando o resultado for 0, usar valor aleatório entre 1 e:")
print("  Para A: valor entre 1 e (dois últimos dígitos / 3)")
print("  Para B: valor entre 1 e (dia do nascimento / 5)")


# PARAEMTRO A
A = random.randint(1, 5)# 15 / 3 = 5
print(f"Como A = 0, então gerando número aleatório entre 1 e {5}: A = {A}")

# PARAMETRO B
B = random.randint(1, 5)# 25 / 5 = 5
print(f"B = 0, então gerando número aleatório entre 1 e {5}: B = {B}")

"""QUESTÃO A)
Escolha todas as cidades da tabela em que (número de cidade) % A = 0 ou (número
de cidade) % B = 0. Utilizando o Google Maps, monte a Matriz de Adjacências do
grafo com as cidades escolhidas, em que os pesos das arestas representam a
distância entre as cidades que possuem estradas entre si (mesmo que elas passem
por outras cidades que não estão selecionadas);



"""

# ==================== Lista de tds as CITYs p/ Item A ====================
cidades = {
    1: "Januária",
    2: "São João das Missões",
    3: "Miravânia",
    4: "Pedras de Maria da Cruz",
    5: "Bonito de Minas",
    6: "Japonvar",
    7: "Montes Claros",
    8: "Itacarambi",
    9: "Manga",
    10: "Montalvânia",
    11: "São Francisco",
    12: "Lontra",
    13: "Mirabela",
    14: "Bocaiúva",
    15: "Brasília de Minas",
    16: "Luislândia",
    17: "Jaíba",
    18: "Verdelândia",
    19: "Varzelândia",
    20: "Janaúba",
    21: "Capitão Enéas"
}

print("Temos no total 21 cidades no norte de MG")

# ==================== Resolução do item A, que consistem em fazer uma seleção das cidades ====================
print("-" * 75)
print("SELEÇÃO DAS CIDADES")
print("-" * 75)
print(f"Condição: (número da cidade) % {A} = 0 OU (número da cidade) % {B} = 0")
print()

# Seleção das cidades conforme a condição do problema
cidades_selecionadas = {}

# Percorre todas as cidades
for num, nome in cidades.items():
    if num % A == 0 or num % B == 0:     # Verifica se o número da cidade é múltiplo de A ou de B
        cidades_selecionadas[num] = nome

print(f"Cidades selecionadas ({len(cidades_selecionadas)} no total):")
for num, nome in sorted(cidades_selecionadas.items()):
    print(f"  {num:2d} - {nome}")
print()

# Mostrar quais cidades foram selecionadas por cada critério
print("Detalhamento por critério:")
for num, nome in sorted(cidades_selecionadas.items()):
    criterios = []
    if num % A == 0:
        criterios.append(f"% {A} = 0")
    if num % B == 0:
        criterios.append(f"% {B} = 0")
    print(f"  Cidade {num:2d}: {nome} → {' e '.join(criterios)}")
print()

# ==================== Matriz de ADJs ====================
print("=-=-=-=-=-=-=-= MATRIZ DE ADJACÊNCIAS =-=-=-=-=-=-=-=")


# Primeiro é feito um mapeamento dos indices

indicesParaNumeros = list(sorted(cidades_selecionadas.keys()))

numerosParaIndices = {num: idx for idx, num in enumerate(indicesParaNumeros)}

### Num de VERTICES
n = len(cidades_selecionadas)

print(f"Mapeamento dos INDICES p/ as {n} CITYs selecionadas:")
for idx, num in enumerate(indicesParaNumeros):
    print(f"  Índice {idx}: {cidades[num]} (cidade {num})")

# criação da matriz de ADJs mas basendo a em distâncias reais
distancias = [[0 for _ in range(n)] for _ in range(n)]

# Lista de conexões entre as cidades (arestas)
# Definir conexões (baseado no maps)
conexoes = [
    # (cidade1, cidade2, distância_km)
    (3, 5, 120),   # Miravânia - Bonito de Minas  =-=-=-=-= Fonte: https://www.google.com/maps/dir/Bonito+de+Minas,+Minas+Gerais/Mirav%C3%A2nia,+MG,+39465-000/@-15.0777275,-44.5828859,10z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x756202bc7c6d239:0xac667bb009dc5039!2m2!1d-44.7550232!2d-15.3238145!1m5!1m1!1s0x757a9bff4e63961:0x72a9dd1ecab47946!2m2!1d-44.4107028!2d-14.7480087!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (3, 6, 166),    # Miravânia - Japonvar =-=-=-=-= Fonte: https://www.google.com/maps/dir/Mirav%C3%A2nia,+MG,+39465-000/Japonvar,+MG,+39335-000/@-15.3724939,-44.367463,9z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x757a9bff4e63961:0x72a9dd1ecab47946!2m2!1d-44.4107028!2d-14.7480087!1m5!1m1!1s0x75457a62ac96745:0xa5c291946ea7a888!2m2!1d-44.2727409!2d-15.9975467!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (5, 6, 115),    # Bonito de Minas - Japonvar =-=-=-=-= Fonte: https://www.google.com/maps/dir/Bonito+de+Minas,+Minas+Gerais/Japonvar,+MG,+39335-000/@-15.6606965,-44.5139049,10z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x756202bc7c6d239:0xac667bb009dc5039!2m2!1d-44.7550232!2d-15.3238145!1m5!1m1!1s0x75457a62ac96745:0xa5c291946ea7a888!2m2!1d-44.2727409!2d-15.9975467!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (5, 9, 153),   # Bonito de Minas - Manga =-=-=-=-= Fonte: https://www.google.com/maps/dir/Bonito+de+Minas,+Minas+Gerais/Manga,+MG,+39460-000/@-15.0450089,-44.3436433,10z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x756202bc7c6d239:0xac667bb009dc5039!2m2!1d-44.7550232!2d-15.3238145!1m5!1m1!1s0x7573081481dc067:0xfc319f19b76c9a0a!2m2!1d-43.9341538!2d-14.7558714!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (6, 9, 176),    # Japonvar - Manga =-=-=-=-= Fonte: https://www.google.com/maps/dir/Japonvar,+MG,+39335-000/Manga,+MG,+39460-000/@-15.3767242,-44.1704268,9z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x75457a62ac96745:0xa5c291946ea7a888!2m2!1d-44.2727409!2d-15.9975467!1m5!1m1!1s0x7573081481dc067:0xfc319f19b76c9a0a!2m2!1d-43.9341538!2d-14.7558714!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (9, 10, 67),   # Manga - Montalvânia =-=-=-=-= Fonte: https://www.google.com/maps/dir/Montalv%C3%A2nia,+MG,+39495-000/Manga,+MG,+39460-000/@-14.5864452,-44.1498311,11z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x75777b72ff4abf1:0x9225e211f9158e93!2m2!1d-44.3673549!2d-14.4220285!1m5!1m1!1s0x7573081481dc067:0xfc319f19b76c9a0a!2m2!1d-43.9341538!2d-14.7558714!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (10, 12, 232),  # Montalvânia - Lontra =-=-=-=-= Fonte: https://www.google.com/maps/dir/Montalv%C3%A2nia,+MG,+39495-000/Lontra,+MG,+39437-000/@-15.1611508,-44.1694587,9z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x75777b72ff4abf1:0x9225e211f9158e93!2m2!1d-44.3673549!2d-14.4220285!1m5!1m1!1s0x754510a95facba3:0xaf526728be13d7e!2m2!1d-44.3024538!2d-15.9046002!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (12, 15, 63), # Lontra - Brasília de Minas =-=-=-=-= Fonte: https://www.google.com/maps/dir/Bras%C3%ADlia+de+Minas,+MG,+39330-000/Lontra,+MG,+39437-000/@-16.0641614,-44.3230459,11z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x7551e7747f2ca0f:0x1f0e6c08a90169d9!2m2!1d-44.433649!2d-16.2131693!1m5!1m1!1s0x754510a95facba3:0xaf526728be13d7e!2m2!1d-44.3024538!2d-15.9046002!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (15, 18, 116),  # Brasília de Minas - Verdelândia =-=-=-=-= Fonte: https://www.google.com/maps/dir/Bras%C3%ADlia+de+Minas,+MG,+39330-000/Varzel%C3%A2ndia,+MG,+39450-000/@-15.9643524,-44.2182425,10z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x7551e7747f2ca0f:0x1f0e6c08a90169d9!2m2!1d-44.433649!2d-16.2131693!1m5!1m1!1s0x75416c8ed32b885:0x4155d43a6616a2da!2m2!1d-44.0316926!2d-15.7049613!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (18, 20, 93),  # Verdelândia - Janaúba =-=-=-=-= Fonte: https://www.google.com/maps/dir/Jana%C3%BAba,+MG,+39440-000/Varzel%C3%A2ndia,+MG,+39450-000/@-15.6896314,-43.6705027,10z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x753d06bdf6cb089:0x499da6e6df630c5!2m2!1d-43.3094187!2d-15.8009305!1m5!1m1!1s0x75416c8ed32b885:0x4155d43a6616a2da!2m2!1d-44.0316926!2d-15.7049613!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (20, 21, 80),  # Janaúba - Capitão Enéas =-=-=-=-= Fonte: https://www.google.com/maps/dir/Jana%C3%BAba,+MG,+39440-000/Cap.+En%C3%A9as,+MG,+39445-000/@-16.0708438,-43.5010322,10z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x753d06bdf6cb089:0x499da6e6df630c5!2m2!1d-43.3094187!2d-15.8009305!1m5!1m1!1s0x75364a5f77e9ba1:0xe7752e5c7af00194!2m2!1d-43.7106813!2d-16.3253656!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
    (3, 21, 261),  # Miravânia - Capitão Enéas =-=-=-=-= Fonte: https://www.google.com/maps/dir/Mirav%C3%A2nia,+MG,+39465-000/Cap.+En%C3%A9as,+MG,+39445-000/@-15.6637349,-43.8794936,8z/data=!3m1!4b1!4m14!4m13!1m5!1m1!1s0x757a9bff4e63961:0x72a9dd1ecab47946!2m2!1d-44.4107028!2d-14.7480087!1m5!1m1!1s0x75364a5f77e9ba1:0xe7752e5c7af00194!2m2!1d-43.7106813!2d-16.3253656!3e0?entry=ttu&g_ep=EgoyMDI2MDIwNC4wIKXMDSoASAFQAw%3D%3D
]

# laço p fzr o perencimento da matriz
for cidade1, cidade2, distancia in conexoes:
      # Só adiciona se ambas as cidades foram selecionadas
    if cidade1 in numerosParaIndices and cidade2 in numerosParaIndices:
        i = numerosParaIndices[cidade1]
        j = numerosParaIndices[cidade2]
        distancias[i][j] = distancia# Aresta i --> j
        distancias[j][i] = distancia # Aresta j --> i (grafo ñ direcionado)


print("\n\nMatriz de Adjacências (distâncias em km):")
print("    " + " ".join(f"{i:4d}" for i in range(n)))
for i in range(n):
    linha = f"{i:2d}: "
    for j in range(n):
        linha += f"{distancias[i][j]:4d}"
    print(linha)

# gera uma lista de arestas existentes
arestas = [(i, j, distancias[i][j]) for i in range(n) for j in range(i+1, n) if distancias[i][j] > 0]
print(f"\nNúmero de arestas no grafo: {len(arestas)}")

print("\nArestas (conexões diretas):")
for i, j, dist in arestas:
    cidade_i = indicesParaNumeros[i]
    cidade_j = indicesParaNumeros[j]
    print(f"  {cidades[cidade_i]} <--> {cidades[cidade_j]}: {dist} km")

"""**QUESTÃO B) O grafo é planar? Prove;**

**o que é um Grafo Planar?** Definição Segundo a Fonte Abaixo

Um grafo é planar se puder ser desenhado no plano sem que haja arestas se
cruzando. Arestas se cruzam (cortam) se há interseção das linhas/arcos que as representam em um ponto que não seja um vértice. Tal desenho é chamado representação planar do grafo. Se o desenho de um grafo tiver cruzamentos, o grafo pode ainda ser planar se puder ser desenhado sem cruzamentos.


**Fonte:** Vozes da Minha Cabeça

https://www.dcc.ufmg.br/~loureiro/md/md_9Grafos_MaterialExtra
"""

# ==================== CHECAGEMN DE PLANAR ====================
print("-" * 75)
print("O GRAFO É PLANAR? isso q pretendo saber tbm")

V = n  # número de vértices
E = len(arestas)  # número de arestas

print(f"a) Dados do grafo:")
print(f"   V = {V} vértices")
print(f"   E = {E} arestas")
print()

print(f"b) Teste da condição necessária para planaridade:")
print(f"   Para grafos planares conexos: E ≤ 3V - 6")
print(f"   {E} ≤ 3×{V} - 6 = {3*V - 6}")
# Teste da condição necessária de planaridade
condicao_necessaria = E <= 3*V - 6
print(f"   Resultado: {condicao_necessaria}")
print()

print(f"c) Verificação de subgrafos K₅ e K₃,₃:")
print(f"   K₅: grafo completo com 5 vértices (requer 10 arestas)")
print(f"   K₃,₃: grafo bipartido completo com 3+3 vértices (requer 9 arestas)")
print()

# Verificação de subgrafo K5
tem_k5 = False
for comb in itertools.combinations(range(V), 5):
    # Contar arestas no subgrafo induzido
    arestas_subgrafo = 0
    for i in range(5):
        for j in range(i+1, 5):
            if distancias[comb[i]][comb[j]] > 0:
                arestas_subgrafo += 1
    # K₅ precisa ter 10 arestas
    if arestas_subgrafo == 10:
        tem_k5 = True
        break

# Verificação de subgrafo K3,3
tem_k33 = False
for comb in itertools.combinations(range(V), 6):
    # Testar todas as partições em dois conjuntos de 3
    for part1 in itertools.combinations(comb, 3):
        part2 = tuple(v for v in comb if v not in part1)
        # Verificar se há aresta entre todos os pares de partições
        bipartido_completo = True
        for v1 in part1:
            for v2 in part2:
                if distancias[v1][v2] == 0:
                    bipartido_completo = False
                    break
            if not bipartido_completo:
                break
        if bipartido_completo:
            tem_k33 = True
            break
    if tem_k33:
        break

print(f"   O grafo contém subgrafo K₅? {tem_k5}")
print(f"   O grafo contém subgrafo K₃,₃? {tem_k33}")
print()

print(f"d) Conclusão sobre planaridade:")
if condicao_necessaria and not tem_k5 and not tem_k33:
    print(f"   ✓ O grafo É PLANAR")
    print(f"   Justificativa:")
    print(f"   1. Satisfaz a condição necessária: E ≤ 3V - 6")
    print(f"   2. Não contém subgrafos K₅ ou K₃,₃")
    print(f"   3. Pode ser desenhado no plano sem cruzamento de arestas")
else:
    print(f"   ✗ O grafo NÃO É PLANAR")
print()

"""**RESPOSTA Do ITEM B:**


Sim, o grafo é planar.

**Provando:** Minha palavra já deveria valer né...


Basicamente a primeira condição necessária para um grafo ser planar é a seguinte:
V -> vértices
E -> arestas

Temos que **E ≤ 3V - 6**

V = 10 vértices

E = 12 arestas

3V - 6 = 3×10 - 6 = 24

12 ≤ 24 essa primeria condição já foi satisfeita.


**Ausência de subgrafos K₅ e K₃,₃:**

K₅ é o que chamamos de um grafo completo com 5 vértices, dessa forma o mesmo requer 10 arestas entre eles.

Já o K₃,₃ é um grafo completo com 3+3 vértices, sendo assim requer 9 arestas conectando todas as arestas entre as  suas partições.

para saber se tinha ou não foi feita uma busca em todas as combinações de 5 vértices para o K₅ e uma 6 vértices para K₃,₃.

O Resultado foi: Nenhum subgrafo foi encontrado.

Com esse resultado já podemos concluir que o grafo satisfaz a condição necessária e não contém subgrafos, portanto dessa forma ele é planar. Isso significa que pode ser desenhado em um plano sem que as arestas se cruzem.

**QUESTÃO C)**

Considerando que, na medida do possível, as sedes não devem ficar em cidades vizinhas, mas todas as cidades não-sede devem ser vizinhas de uma sede, Detalhe um método ou algoritmo para encontrar o menor número possível de sedes e em quais cidades elas estarão localizadas, e prove sua escolha embasando-se nas teorias estudadas na disciplina.;
"""

# ==================== NÚMERO DE SEDES ====================

print("-" * 75)
print("NÚMERO DE SEDES")

  # Função que recebe um conjunto de vértices
  # e verifica se nenhum deles é vizinho de outro
def conjunto_independente(vertices):
    for i in range(len(vertices)):         # Percorre os vértices usando o índice i
        for j in range(i+1, len(vertices)):             # Isso evita comparar um vértice com ele mesmo e evita repetições
            if distancias[vertices[i]][vertices[j]] > 0: # Se a distância entre dois vértices for maior que zero então existe uma aresta entre eles (são vizinhos)
                return False
    return True

def conjunto_dominante(vertices, todos_vertices):
    # Função que verifica se o conjunto de vértices domina todo o grafo
    dominados = set(vertices)
    for v in vertices:
        for u in todos_vertices:
            if distancias[v][u] > 0: # Se existir uma aresta entre v e u,então u é vizinho de v
                dominados.add(u)
    return len(dominados) == len(todos_vertices)

# aq é feita uma busca p/ achar o menor conjunto q seja um dominante independente
todos_vertices = list(range(V))
solucao = None # Variável que armazenará o conjunto solução encontrado
tamanho_minimo = V + 1 # Inicializa o menor tamanho possível como um valor maior que V


print("Buscando solução ótima...")
for tamanho in range(1, V+1):     # Testa subconjuntos começando do menor tamanho possível 1 até o número total de vértices V
    encontrado = False
    for combinacao in itertools.combinations(todos_vertices, tamanho):         # Gera todas as combinações possíveis de vértices
        if (conjunto_independente(combinacao) and
            conjunto_dominante(combinacao, todos_vertices)): # Verifica se a combinação é ao mesmo tempo independente e dominate
            solucao = combinacao
            tamanho_minimo = tamanho
            encontrado = True
            break
    if encontrado:
        break

print(f"Solução encontrada: {len(solucao)} sedes")
print("Cidades-sede:")
for idx in solucao:
    num_cidade = indicesParaNumeros[idx]
    print(f"  - {cidades[num_cidade]} (cidade {num_cidade})")
print()

# Verificar a solução
print("Verificação da solução:")
# independencia
print("1. Independência (nenhuma sede é vizinha de outra):")
independencia_ok = True
for i in range(len(solucao)):
    for j in range(i+1, len(solucao)):
        if distancias[solucao[i]][solucao[j]] > 0:
            independencia_ok = False
            break
    if not independencia_ok:
        break
print(f"   ✓ OK" if independencia_ok else "   ✗ FALHOU")

#dominancia
print("2. Dominância (cada cidade não-sede é vizinha de alguma sede):")
dominancia_ok = True
cidades_nao_sede = [v for v in todos_vertices if v not in solucao] # Cria uma lista com todas as cidades que NÃO são sedes

for cidade in cidades_nao_sede:     # Percorre cada cidade não-sede
    vizinha_de_sede = False     # Marca se a cidade é vizinha de alguma sede
    for sede in solucao:         # Percorre todas as sedes
        if distancias[cidade][sede] > 0:
            vizinha_de_sede = True             # Se existir uma aresta entre a cidade e a sede
            break
    if not vizinha_de_sede:         # Se a cidade não for vizinha de nenhuma sede
        num_cidade = indicesParaNumeros[cidade]
        print(f"   ✗ {cidades[num_cidade]} não é vizinha de nenhuma sede")
        dominancia_ok = False         # Marca que a dominância falhou
        break
if dominancia_ok:
    print(f"   ✓ OK")
print()

print("Prova da minimalidade:")
print(f"Teorema: Para qualquer grafo, o número mínimo de sedes é pelo menos")
print(f"         ⌈n/(Δ+1)⌉, onde n é o número de cidades e Δ é o grau máximo.")
print()

# Calcula o grau de cada vértice:
# conta quantas arestas cada vértice possui
graus = [sum(1 for j in range(V) if distancias[i][j] > 0) for i in range(V)]
grau_maximo = max(graus)
limite_inferior = math.ceil(V / (grau_maximo + 1))

print(f"n = {V} cidades")
print(f"Δ = {grau_maximo} (grau máximo)")
print(f"⌈{V}/({grau_maximo}+1)⌉ = ⌈{V}/{grau_maximo+1}⌉ = {limite_inferior}")
print(f"Nossa solução tem {len(solucao)} sedes, que é ≥ {limite_inferior} (ótima)")
print()

"""**RESPOSTA DO ITEM C:**

Proposta
Para encontrar o menor conjunto de cidades-sede que satisfaça as condições:

* Nenhuma sede é vizinha de outra.

* Toda cidade não-sede é vizinha de pelo menos uma sede.

Dessa forma baseamos a busca em:

Gerar todos os subconjuntos de vértices, do menor tamanho possível até encontrar uma solução.

Para cada subconjunto, verificar independência e dominância.

A primeira solução encontrada (com menor tamanho) é ótima.

**QUESTÃO D)**

Considerando que todo o transporte de encomendas para cidades não-vizinhas deve passar por uma sede, proponha um algoritmo que encontre o subgrafo que otimize a distribuição das rotas e justifique utilizando as teorias estudadas na disciplina.
"""

# ==================== SUBGRAFO p/ OTIMIZAÇÂO ====================
print("-" * 75)
print("SUBGRAFO QUE OTIMIZA A DISTRIBUIÇÃO DE ROTAS")
print("Requisito: Todo transporte entre cidades não-vizinhas deve passar por uma sede\n")

print("Algoritmo proposto:")
print("1. Atribuir cada cidade não-sede à sede mais próxima (Dijkstra)")
print("2. Conectar as sedes entre si com Árvore Geradora Mínima (Prim)")
print("3. Subgrafo = união dos caminhos cidade-sede + AGM entre sedes\n")

# implementand o Dijkstra
def dijkstra(origem):
    dist = [float('inf')] * V
    dist[origem] = 0
    visitado = [False] * V
    anterior = [-1] * V

    for _ in range(V):
        # Encontrar vértice não visitado com menor distância
        u = -1
        min_dist = float('inf')
        for i in range(V):
            if not visitado[i] and dist[i] < min_dist:
                min_dist = dist[i]
                u = i
        if u == -1:
            break
        visitado[u] = True

        # Atualizar vizinhos
        for v in range(V):
            if distancias[u][v] > 0 and not visitado[v]:
                nova_dist = dist[u] + distancias[u][v]
                if nova_dist < dist[v]:
                    dist[v] = nova_dist
                    anterior[v] = u

    return dist, anterior

# Atribuir cidades não-sede às sedes mais próximas
print("1. Atribuição de cidades não-sede:")
atribuicoes = {sede: [] for sede in solucao}

for cidade in cidades_nao_sede:
    dist_min = float('inf')
    sede_mais_proxima = None

    for sede in solucao:
        dist, _ = dijkstra(sede)
        if dist[cidade] < dist_min:
            dist_min = dist[cidade]
            sede_mais_proxima = sede

    if sede_mais_proxima is not None:
        atribuicoes[sede_mais_proxima].append(cidade)
        num_cid = indicesParaNumeros[cidade]
        num_sede = indicesParaNumeros[sede_mais_proxima]
        print(f"   {cidades[num_cid]} → {cidades[num_sede]} ({dist_min} km)")

print()

# Implementar Prim p/ o AGM
print("2. Árvore Geradora Mínima entre sedes:")
def prim(vertices):
    n = len(vertices)
    # Matriz local
    matriz = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                matriz[i][j] = distancias[vertices[i]][vertices[j]]

    # Algoritmo de Prim
    selecionados = [False] * n
    selecionados[0] = True
    arestas = []
    peso_total = 0

    for _ in range(n-1):
        min_peso = float('inf')
        u, v = -1, -1
        for i in range(n):
            if selecionados[i]:
                for j in range(n):
                    if not selecionados[j] and matriz[i][j] > 0 and matriz[i][j] < min_peso:
                        min_peso = matriz[i][j]
                        u, v = i, j
        if u != -1:
            arestas.append((vertices[u], vertices[v], min_peso))
            peso_total += min_peso
            selecionados[v] = True

    return arestas, peso_total

# Calcular AGM
lista_sedes = list(solucao)
arestas_agm, peso_agm = prim(lista_sedes)

print("   Arestas da AGM:")
for u, v, peso in arestas_agm:
    num_u = indicesParaNumeros[u]
    num_v = indicesParaNumeros[v]
    print(f"   {cidades[num_u]} — {cidades[num_v]}: {peso} km")
print(f"   Peso total: {peso_agm} km")
print()

print("3. Subgrafo final:")
print("   Caminhos mais curtos de cada cidade não-sede à sua sede")
print("   AGM conectando todas as sedes")
print("   Este subgrafo minimiza o custo total das rotas.")
print()

"""**RESPOSTA DO ITEM D:**

Algoritmo proposto p/ Resolução:
O algoritmo consiste em duas etapas:

Atribuição de cidades não-sede às sedes mais próximas:

Para cada cidade não-sede, calcular a distância mínima até cada sede usando o algoritmo de Dijkstra.

Atribuir a cidade não-sede à sede com menor distância mínima.

Incluir no subgrafo o caminho mínimo (conjunto de arestas) entre a cidade não-sede e sua sede atribuída.

**Conexão entre as sedes:**

Calcular uma Árvore Geradora Mínima (AGM) sobre o subgrafo induzido pelas sedes, usando o algoritmo de Prim (ou Kruskal).

A AGM conecta todas as sedes com o menor custo total de arestas.

Adicionar as arestas da AGM ao subgrafo.

Subgrafo Final
O subgrafo ótimo é a união de:

Todos os caminhos mínimos das cidades não-sede às suas sedes atribuídas.

A Árvore Geradora Mínima que conecta todas as sedes.

**Justificativa**

**Algoritmo de Dijkstra:** Garante que cada cidade não-sede esteja conectada à sua sede pelo caminho de menor custo, minimizando as distâncias individuais. Complexidade: O(V²) para implementação com matriz de adjacências.

**Algoritmo de Prim:** Garante que todas as sedes estejam conectadas entre si com o menor custo total, formando uma árvore que minimiza a soma dos pesos das arestas. Complexidade: O(V²).

A combinação resulta em um subgrafo que minimiza a soma total das distâncias percorridas, satisfazendo a restrição de que todo transporte entre cidades não-vizinhas passe por uma sede.

**QUESTÂO E):**

Considerando que os motoristas partem das cidades não-sede para uma cidade-sede e voltam, detalhe um método para organizar a tabela de horários para que não haja mais do que um motorista chegando ou saindo ao mesmo tempo e justifique seu método com base nas teorias estudadas na disciplina.
"""

# ==================== Metodo p/ Tabela De Horarios ====================

# Parâmetros
velocidade = 60  # km/h
tempo_servico = 0.5  # 30 minutos em horas
intervalo = 1.0  # 1 hora entre partidas

print(f"Parâmetros:")
print(f"- Velocidade média: {velocidade} km/h")
print(f"- Tempo de serviço na sede: {tempo_servico*60} minutos")
print(f"- Intervalo entre partidas: {intervalo*60} minutos")
print()

print("TABELA DE HORÁRIOS:")
print("=" * 75)
print(f"{'Cidade de origem':<20} {'Sede':<20} {'Partida':<10} {'Chegada':<10} {'Retorno':<10} {'Volta':<10}")
print("-" * 75)

horarios = {}
hora_atual = 8.0  # Início às 8:00

for sede, cidades_atrib in atribuicoes.items():     # Percorre cada sede e a lista de cidades atribuídas a ela
    for cidade in cidades_atrib:         # Percorre cada cidade não-sede associada à sede atual
        # Calcular tempo de viagem
        tempo_viagem = distancias[cidade][sede] / velocidade

        # Definir horários
        partida = hora_atual
        chegada = partida + tempo_viagem
        retorno = chegada + tempo_servico
        volta = retorno + tempo_viagem

        # Armazenar
        horarios[(cidade, sede)] = {
            'partida': partida,
            'chegada': chegada,
            'retorno': retorno,
            'volta': volta
        }

        num_cidade = indicesParaNumeros[cidade]   # Converte o índice interno da cidade para o número real da cidade

        num_sede = indicesParaNumeros[sede]  # Converte o índice interno da sede para o número real da sede


        def formatar_hora(hora):
            horas = int(hora)
            minutos = int((hora - horas) * 60)
            return f"{horas:02d}:{minutos:02d}"

        print(f"{cidades[num_cidade]:<20} {cidades[num_sede]:<20} "
              f"{formatar_hora(partida):<10} {formatar_hora(chegada):<10} "
              f"{formatar_hora(retorno):<10} {formatar_hora(volta):<10}")

        # Incrementa o horário atual garantindo que
        # não haja partidas simultâneas
        hora_atual += intervalo


print("=" * 75)

"""**RESPOSTA DO ITEM E:**


**Método Proposto: Escalonamento por Intervalos Fixos**

Foi pensado em desenvolver um método específico para organizar a tabela de horários que atendesse de forma rigorosa ao requisito de evitar múltiplas chegadas ou saídas simultâneas.


**Justificativa**

O método utiliza princípios de escalonamento periódico com intervalos fixos, similar a algoritmos como Round Robin que é muito utilizado em sistemas operacionais. A escolha de um intervalo fixo de 1 hora cria uma grade temporal regular que elimina a possibilidade de sobreposição. Por construção: Como cada motorista parte em horários diferentes (T e T+1 hora), seus horários de chegada serão necessariamente diferentes.

**QUESTÃO F)**

Para a questão anterior, qual o número máximo de automóveis que poderão estar circulando simultaneamente?
"""

# ==================== AcharR o Num Max de automovel ====================
print("-" * 75)
print("NÚMERO MÁXIMO DE AUTOMÓVEIS CIRCULANDO SIMULTANEAMENTE")

# Simulação ao longo do dia
tempos = [i/10 for i in range(80, 181)]  # 8:00 às 18:00
max_veiculos = 0
hora_pico = 0

for tempo in tempos:  # Percorre cada instante de tempo da simulação
    veiculos_ativos = 0
    for info in horarios.values():  # Percorre todas as viagens armazenadas no dicionário horarios
        if info['partida'] <= tempo <= info['volta']:  # Verifica se o instante atual está entre a partida e a volta do veículo
            veiculos_ativos += 1
    if veiculos_ativos > max_veiculos:   # Se o número atual de veículos for maior que o máximo já registrado
        max_veiculos = veiculos_ativos
        hora_pico = tempo

print(f"RESULTADO: {max_veiculos} veículos simultâneos")
print(f"Hora de pico: {int(hora_pico):02d}:{int((hora_pico%1)*60):02d}")
print()

# Cálculo do limite teórico
print("Cálculo do limite teórico:")
print(f"- Total de cidades não-sede: {len(cidades_nao_sede)}")
print(f"- Com intervalo de {intervalo} hora(s) entre partidas")
print(f"- Tempo médio de ciclo (ida+serviço+volta): variável")
print()

print(f"O número máximo ocorre quando há sobreposição máxima de viagens.")
print(f"No nosso escalonamento, o máximo é {max_veiculos} de {len(cidades_nao_sede)} possíveis.")
print()

"""Com base na simulação realizada através do código implementado, o número máximo de automóveis que podem estar circulando simultaneamente é 2 veículos.

Hora de pico: 09:00


O método de escalonamento por intervalos fixos garante que não haja mais de uma chegada ou saída ao mesmo tempo em uma mesma sede. No entanto, como há apenas duas cidades não-sede, o número máximo possível de veículos em circulação simultânea não pode exceder 2.
"""