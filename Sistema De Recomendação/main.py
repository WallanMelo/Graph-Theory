# -*- coding: utf-8 -*-
"""Sistema De Recomendação - Grafos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1faxHhcDj5GHAyNCwfYhv_M4RBHGMdgCs

*Nome:* Wallan De Melo Lima
"""

import numpy as np
import random

# Esta função é responsável por gerar uma matriz de adjacência que representa
# uma rede social entre usuários. Cada posição da matriz indica a existência
# e a intensidade da relação entre dois usuários.
#
# A probabilidade de conexão é calculada com base no grau máximo desejado (d_max)
# em relação ao número total de usuários. Caso uma conexão seja criada, é atribuído
# um peso aleatório que representa o nível de interação ou afinidade entre os usuários.
#
# Parâmetros:
# - n: número total de usuários da rede.
# - d_max: grau máximo esperado de conexões por usuário.
#
# Retorno:
# - Uma matriz quadrada (n x n) contendo os pesos das conexões sociais.

def gerar_rede_social(n, d_max):
    prob = d_max/n
    matriz_adj = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if np.random.rand() < prob:
                peso = np.random.randint(1, 200)
                matriz_adj[i, j] = peso
    return matriz_adj

# Esta função gera uma matriz que representa a relação entre usuários e produtos,
# simulando compras ou avaliações realizadas por cada usuário.
#
# Cada linha representa um usuário e cada coluna representa um produto.
# A presença de um valor diferente de zero indica que o usuário interagiu
# com o produto, e o valor armazenado representa o peso dessa interação,
# como uma avaliação ou frequência de compra.
#
# A probabilidade de interação é controlada pelo parâmetro p_max em relação
# ao total de produtos disponíveis.
#
# Parâmetros:
# - n: número de usuários.
# - p: número de produtos.
# - p_max: limite máximo usado para calcular a probabilidade de interação.
#
# Retorno:
# - Uma matriz (n x p) representando as interações entre usuários e produtos.
def gerar_rede_compras(n, p, p_max):
    prob = p_max/p
    matriz_adj = np.zeros((n, p))
    for i in range(n):
        for j in range(p):
            if np.random.rand() < prob:
                peso = np.random.randint(1, 5)
                matriz_adj[i, j] = peso
    return matriz_adj

# Esta função implementa um sistema simples de recomendação de produtos
# baseado na rede social dos usuários e no histórico de compras/avaliações.
#
# O método utiliza multiplicação matricial para calcular um score de afinidade
# entre um usuário e os produtos, levando em consideração as interações
# sociais com outros usuários e as avaliações já realizadas.
#
# Produtos que o usuário já comprou ou avaliou são excluídos das recomendações,
# garantindo que apenas novos produtos sejam sugeridos.
#
# Ao final, são selecionados os k produtos com maior pontuação para cada usuário.
#
# Parâmetros:
# - matriz_social: matriz de adjacência da rede social entre usuários.
# - matriz_compras: matriz de interações entre usuários e produtos.
# - k: número de produtos a serem recomendados.
#
# Retorno:
# - Um dicionário onde cada chave representa um usuário e o valor é uma lista
#   com os índices dos produtos recomendados.
def recomendar_produtos(matriz_social, matriz_compras, k):
    num_usuarios = matriz_social.shape[0]
    recomendacoes = {}

    for i in range(num_usuarios):
        ### multiplicação entre as matrizes de rede social * compra ---> para obter o score de afinidade entre o usuario e as avaliações de tds os outros usuarios, e o result é esse score para cada produto
        scores = np.dot(matriz_social[i, :], matriz_compras)

        ### identifica os produtos que o usuário já avaliou/comrpou
        produtos_vistos = np.where(matriz_compras[i, :] != 0)[0]

        ### define um valor infinitamente negativo para que esses produtos não possoa aparecer na recomendação
        scores[produtos_vistos] = -np.inf

        ### pega os indices dos k_produtos com maiores pontuações, e ordena os indices do menor p/ maior score e inverte a sua ordem p/ que o procuto mais recomendado venha primeiro
        indices_recomendados = np.argsort(scores)[-k:][::-1]

        recomendacoes[i] = indices_recomendados.tolist()#armazena a lista dos indices dos produtos no dict

    return recomendacoes

## ======= INTERFACE p/ TESTE =======
try:
    max_ususarios = int(input("Digite o limite máximo para sorteio de Usuários: "))
    max_produtos = int(input("Digite o limite máximo para sorteio de Produtos: "))
    max_k_recomendacoes = int(input("Digite o limite máximo para K-recomendações: "))

    N_USUARIOS = random.randint(1, max_ususarios)
    N_PRODUTOS = random.randint(1, max_produtos)
    K_RECOMENDACOES = random.randint(1, min(max_k_recomendacoes, N_PRODUTOS))# p/ garantir q o K ñ seja > q o total de produtos disponiveis

    print(f"\n========= Cenário De Teste Gerado Aleatoriamente =========")
    print(f"Usuários: {N_USUARIOS} | Produtos: {N_PRODUTOS} | K: {K_RECOMENDACOES}")

    # matrizes geradas
    matriz_contatos = gerar_rede_social(n=N_USUARIOS, d_max=5)
    matriz_avaliacoes = gerar_rede_compras(n=N_USUARIOS, p=N_PRODUTOS, p_max=15)

    resultado = recomendar_produtos(matriz_contatos, matriz_avaliacoes, k=K_RECOMENDACOES)

    # ======= LISTA DE RECOMENDAÇÕES p/ TODOS OS USUÁRIOS =======
    print(f"\n========= Relatório de Recomendações (Todos os {N_USUARIOS} usuários) =========")
    for usuario_id, lista_produtos in resultado.items():
        print(f"Usuário {usuario_id}: Produtos Recomendados {lista_produtos}")

except ValueError:
    print("Erro: Por favor, digite  números inteiros.")