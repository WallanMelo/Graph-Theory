# -*- coding: utf-8 -*-
"""2 Lista de Exercicios - Grafos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SSG4f-oWOzMgvuHfclib04bNbjgax6Qw

*Nome:* Wallan De Melo Lima
"""

import time

# === QUESTÃO 1 ===
# Esta função constrói um grafo que representa um hipercubo de dimensão S.
# Cada vértice é representado por uma string binária de tamanho S, onde cada
# combinação possível de bits corresponde a um vértice distinto.
#
# As arestas do grafo são definidas entre vértices que diferem em exatamente
# um bit, caracterizando a adjacência típica de um hipercubo.
#
# Parâmetros:
# - S: dimensão do hipercubo.
#
# Retorno:
# - V: lista contendo todos os vértices do hipercubo.
# - E: lista de arestas que conectam vértices com distância de Hamming igual a 1.

def gerar_hipercubo(S):
    V = [bin(i)[2:].zfill(S) for i in range(2**S)]
    E = []
    for i in range(len(V)):
        for j in range(i + 1, len(V)):
            diferencas = sum(1 for a, b in zip(V[i], V[j]) if a != b)
            if diferencas == 1:
                E.append((V[i], V[j]))
    return V, E

# === QUESTÃO 2 ===
# Esta função gera o grafo de estados do jogo da velha.
# Cada vértice representa uma configuração possível do tabuleiro,
# modelada como uma string de 9 caracteres.
#
# As arestas representam jogadas válidas entre estados, respeitando
# a alternância correta entre os jogadores 'x' e 'o'.
#
# O grafo é construído por meio de uma busca em largura, garantindo
# que todos os estados alcançáveis a partir do tabuleiro vazio sejam gerados.
#
# Retorno:
# - V: conjunto contendo todos os estados possíveis do jogo.
# - E: lista de arestas que representam as transições entre estados.

def gerar_grafo_velha():
    inicial = '-' * 9
    V = {inicial}
    E = []
    fila = [inicial]

    while fila:
        estado_atual = fila.pop(0)
        jogadas_x = estado_atual.count('x')
        jogadas_o = estado_atual.count('o')
        simbolo_da_vez = 'x' if jogadas_x == jogadas_o else 'o'

        for i in range(9):
            if estado_atual[i] == '-':
                lista_estado = list(estado_atual)
                lista_estado[i] = simbolo_da_vez
                novo_estado = "".join(lista_estado)

                if novo_estado not in V:
                    V.add(novo_estado)
                    fila.append(novo_estado)

                E.append((estado_atual, novo_estado))
    return V, E

# === FUNÇÃO AUXILIAR PARA CORRIGIR O ERRO ===
# Esta função auxiliar retorna todos os vértices vizinhos de um dado nó,
# com base em uma lista de arestas direcionadas.
#
# Ela percorre a lista de arestas e seleciona todos os nós que podem ser
# alcançados diretamente a partir do nó informado.
#
# Parâmetros:
# - no: vértice de origem.
# - arestas: lista de arestas do grafo.
#
# Retorno:
# - Lista de vértices adjacentes ao nó fornecido.

def obter_vizinhos(no, arestas):
    """Retorna todos os nós 'v' tais que existe uma aresta (no, v)"""
    return [v for (u, v) in arestas if u == no]

# Esta função constrói uma árvore geradora a partir de um grafo representado
# por uma lista de arestas, utilizando uma estratégia de busca em largura.
#
# O algoritmo inicia a partir de um vértice raiz e expande a árvore
# visitando cada vértice apenas uma vez, evitando ciclos.
#
# A árvore resultante conecta todos os vértices alcançáveis a partir do
# vértice inicial, contendo exatamente V-1 arestas.
#
# Parâmetros:
# - grafo_E: lista de arestas do grafo original.
# - inicio: vértice raiz da árvore.
#
# Retorno:
# - Lista de arestas que compõem a árvore geradora.

def criar_arvore_jogadas(grafo_E, inicio):
    """
    Cria uma árvore geradora a partir de uma lista de arestas (grafo_E).
    """
    visitados = {inicio}
    arvore_E = []
    fila = [inicio]

    while fila:
        u = fila.pop(0)
        # Agora chamamos a função auxiliar passando a lista de arestas
        for v in obter_vizinhos(u, grafo_E):
            if v not in visitados:
                visitados.add(v)
                arvore_E.append((u, v))
                fila.append(v)
    return arvore_E

# === FUNCT p/ TESTAR ===
# Esta função executa uma série de testes para validar a correta construção
# dos grafos e da árvore geradora.
#
# São verificados:
# - o número de vértices e arestas do hipercubo,
# - a geração do grafo de estados do jogo da velha,
# - a criação de uma árvore geradora e seu tempo de execução.
#
# O objetivo é confirmar a consistência dos resultados e o correto
# funcionamento dos algoritmos implementados.

def executar_todos_os_testes():
    print("=== INICIANDO TESTES DE GRAFOS ===\n")

    # Teste 1: Hipercubo
    v_hc, e_hc = gerar_hipercubo(3)
    print(f"1. Hipercubo S=3: V={len(v_hc)}, E={len(e_hc)} (Esperado: 8 e 12)")

    # Teste 2: Jogo da Velha
    v_velha, e_velha = gerar_grafo_velha()
    print(f"2. Grafo Velha: V={len(v_velha)}, E={len(e_velha)}")

    # Teste 3: Árvore Geradora (Usando a função que estava dando erro)
    print("3. Gerando Árvore a partir de '---------'...")
    inicio_tempo = time.time()
    arvore = criar_arvore_jogadas(e_velha, '---------')
    fim_tempo = time.time()

    print(f"   Arestas na árvore: {len(arvore)}")
    print(f"   Tempo de processamento: {fim_tempo - inicio_tempo:.4f}s")
    print(f"   V-1 = E? {'Sim' if len(arvore) == len(v_velha)-1 else 'Não'}")
    print("\n=== TESTES FINALIZADOS ===")

if __name__ == "__main__":
    executar_todos_os_testes()